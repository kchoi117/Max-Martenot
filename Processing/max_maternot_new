//Max Martenot
//October 28th, 2016

//Data input: pitchPot(0-1023), reverbPot(0-1023), photoSensor(0-1023), switches(0-1);

import processing.sound.*;  //import the Sound library for oscillations and reverb
import processing.serial.*; //import the Serial library so we can read from arudino input via serial communication

int end = 10;    // the number 10 is ASCII for linefeed (end of serial.println), later we will look for this to break up individual messages
String serial;   // declare a new string called 'serial' 
Serial port;     // The serial port, this is a new instance of the Serial class (an Object)
int[] serialInputInt; // Array of integers to contain serial input

int numberOfSwitches = 6;

//declare instances of sound objects
SinOsc sinOsc;
SinOsc sinOscH;
SinOsc sinOscL;
TriOsc triOsc;
SawOsc sawOsc;
SqrOsc sqrOsc;

Reverb reverbSin;
Reverb reverbSinH;
Reverb reverbSinL;
Reverb reverbTri;
Reverb reverbSaw;
Reverb reverbSqr;

int[] switches = new int[6];
int[] switchesOld = new int[6];

int pitchPot;
float pitchFreq;
int reverbPot;
float reverbValue;
int photoSensor;
float ampValue;
int i = 0;

float f[] = {20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800,
     1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500};

float af[] = {0.532, 0.506, 0.480, 0.455, 0.432, 0.409, 0.387, 0.367, 0.349, 0.330, 0.315,
      0.301, 0.288, 0.276, 0.267, 0.259, 0.253, 0.250, 0.246, 0.244, 0.243, 0.243,
      0.243, 0.242, 0.242, 0.245, 0.254, 0.271, 0.301};

float lu[] = {-31.6, -27.2, -23.0, -19.1, -15.9, -13.0, -10.3, -8.1, -6.2, -4.5, -3.1,
       -2.0,  -1.1,  -0.4,   0.0,   0.3,   0.5,  0.0, -2.7, -4.1, -1.0,  1.7,
        2.5,   1.2,  -2.1, -7.1, -11.2, -10.7,  -3.1};

float tf[] = {78.5,  68.7, 59.5,  51.1,  44.0,  37.5,  31.5,  26.5,  22.1,  17.9,  14.4,
       11.4,   8.6,   6.2,   4.4,  3.0,   2.2,  2.4,   3.5,   1.7,  -1.3,  -4.2,
       -6.0,  -5.4,  -1.5,   6.0,  12.6,  13.9,  12.3};

float vAf;
float spl;
float phon;
int ndx;
void setup() {
  //serial reading code
  //when testing, this next line should be the ONLY line to cause an error: ArrayIndexOutOfBoundsExcpetion: 0
  port = new Serial(this, Serial.list()[0], 9600); // initializing the object by assigning a port and baud rate (must match that of Arduino)
  port.clear();  // function from serial library that throws out the first reading, in case we started reading in the middle of a string from Arduino
  serial = port.readStringUntil(end); // function that reads the string from serial port until a println and then assigns string to our string variable (called 'serial')
  serial = null; // initially, the string will be null (empty)
  
  //run data in the buffer once to ensure that we splice the data properly when we begin processing the data in draw()
  delay(50);
  serial = port.readStringUntil(10);
  if (serial != null) { 
    String[] serialInput = split(serial, ',');
    serialInputInt = int(serialInput);
  }
  
  //initialize instances of sound objects
  sinOsc = new SinOsc(this);
  sinOscH = new SinOsc(this);
  sinOscL = new SinOsc(this);
  triOsc = new TriOsc(this);
  sawOsc = new SawOsc(this);
  sqrOsc = new SqrOsc(this);
  
  reverbSin = new Reverb(this);
  reverbSinH = new Reverb(this);
  reverbSinL = new Reverb(this);
  reverbTri = new Reverb(this);
  reverbSaw = new Reverb(this);
  reverbSqr = new Reverb(this);
  
} //end setup

void draw() {
  //****************GET SERIAL DATA AND READ IT*******************************
  //if there is data coming from the serial port read it/ store it
  while (port.available() > 0) { 
    serial = port.readStringUntil(end);
  } //end while
  i++;
  //if the string is not empty, do this
  if (serial != null) { 
    //sensor input from Arduino, each value is separated and split depending on the ','
    //and then saved in separate cells of the array so we can access each 
    String[] serialInput = split(serial, ','); 
    //can help to print these to console at this point to check it's working
    /*for (String s : serialInput) {
      print(s + ", ");
    }
    print("\n");*/

    //convert the string inputs that are stored in the serialInputInt array, which will then be further decomposed
    serialInputInt = int(serialInput);
    
    //copy switches to switchesOld
    arrayCopy(switches, switchesOld);
    
    //parse values
    pitchPot = serialInputInt[0];
    reverbPot = serialInputInt[1];
    photoSensor = serialInputInt[2];
    arrayCopy(serialInputInt, 3, switches, 0, numberOfSwitches);
    
    //convert linear pot input from MIDI to frequencies
    pitchFreq = pow(2, (pitchPot/10.0 - 69) / 12) * 440;
    //convert reverb pot input into 0 to 1 value
    reverbValue = map(reverbPot, 0, 1023, 0.0, 1.0);
    //conver photoSensor input into 0 to 1 value
    ampValue = map(photoSensor, 0, 1023, 0.0, 1.0);
    
    //debugging
    println(pitchFreq + " " + reverbValue + " " + ampValue);
    printArray(switches);
    
     // match the discretized values of f with the value of pitchFreq:
    boolean match = false;
    int ndx = 14; // should be about half of 29
    
    match = pitchFreq >= f[ndx] && pitchFreq <= f[ndx + 1];
   int oldndx = 28;
   int temp;
   while (!match) {
        if (pitchFreq <= f[ndx]) {
          oldndx = ndx;
          ndx = ndx / 2;
        }else if (pitchFreq <= f[0]) {
          ndx = 0;
        }else if (pitchFreq >= f[28]) {
          ndx = 28;
        } else if (pitchFreq >= f[ndx + 1]){
          temp = oldndx;
          ndx =  ndx+(oldndx-ndx)/2;
          oldndx = temp;
        }
        match = (pitchFreq >= f[ndx] && pitchFreq <= f[ndx + 1]) || pitchFreq >= f[28] || pitchFreq <= f[0];
    }
    
    // now ndx is the index value of f in which pitchFreq is in between
    
    // find phon:
    phon = 20 * log(ampValue);
    
    // find spl:
    
    // exponents in java: pow(x,y) where x^y; uses double types (jk processing doesn't use doubles)
    // logarithms in java: log(x) where ln(x); uses double types
    float tmp1 = pow(10,(0.025*phon)) - 1.15;
    float tmp15 = pow(10, tf[ndx] + lu[ndx]);
    float tmp2 = pow(0.4 * tmp15/10 - 9, af[ndx]);
    vAf = 0.00447 * tmp1 + tmp2;
    spl = ((10/af[ndx]) * (log(vAf)/log(vAf))) - lu[ndx] + 94;
    
    //debugging
    println(pitchFreq + " " + reverbValue + " " + ampValue);
    printArray(switches);
    
    //activate/stop oscillations if state has changed
    if (switches[0] - 1 == switchesOld[0]) {
      sinOsc.play();
      reverbSin.process(sinOsc);
    }
    if (switches[0] == switchesOld[0] - 1) {
      sinOsc.stop();
      reverbSin.stop();
    }
    if (switches[1] - 1 == switchesOld[1]) {
      sinOscH.play();
      reverbSinH.process(sinOscH);
    }
    if (switches[1] == switchesOld[1] - 1) {
      sinOscH.stop();
      reverbSinH.stop();
    }
    if (switches[2] - 1 == switchesOld[2]) {
      sinOscL.play();
      reverbSinL.process(sinOscL);
    }
    if (switches[2] == switchesOld[2] - 1) {
      sinOscL.stop();
      reverbSinL.stop();
    }
    if (switches[3] - 1 == switchesOld[3]) {
      triOsc.play();
      reverbTri.process(triOsc);
    }
    if (switches[3] == switchesOld[3] - 1) {
      triOsc.stop();
      reverbTri.stop();
    }
    if (switches[4] - 1 == switchesOld[4]) {
      sawOsc.play();
      reverbSaw.process(sawOsc);
    }
    if (switches[4] == switchesOld[4] - 1) {
      sawOsc.stop();
      reverbSaw.stop();
    }
    if (switches[5] - 1 == switchesOld[5]) {
      sqrOsc.play();
      reverbSqr.process(sqrOsc);
    }
    if (switches[5] == switchesOld[5] - 1) {
      sqrOsc.stop();
      reverbSqr.stop();
    }
    //set oscillation frequencies
    if (switches[0] == 1) {
      sinOsc.freq(pitchFreq);
      sinOsc.amp(ampValue);
      reverbSin.room(reverbValue);
      reverbSin.damp(reverbValue);
    }
    if (switches[1] == 1) {
      sinOscH.freq(pitchFreq);
      sinOscH.amp(ampValue);
      reverbSinH.room(reverbValue);
      reverbSinH.damp(reverbValue);
    }
    if (switches[2] == 1) {
      sinOscL.freq(pitchFreq);
      sinOscL.amp(ampValue);
      reverbSinL.room(reverbValue);
      reverbSinL.damp(reverbValue);
    }
    if (switches[3] == 1) {
      triOsc.amp(ampValue);
      triOsc.freq(pitchFreq);
      reverbTri.room(reverbValue);
      reverbTri.damp(reverbValue);
    }
    if (switches[4] == 1) {
      sawOsc.freq(pitchFreq);
      sawOsc.amp(ampValue);
      reverbSaw.room(reverbValue);
      reverbSaw.damp(reverbValue);
    }
    if (switches[5] == 1) {
      sqrOsc.freq(pitchFreq);
      sqrOsc.amp(ampValue);
      reverbSqr.room(reverbValue);
      reverbSqr.damp(reverbValue);
    }
    
  } //stop reading serial
  println(i);
  delay(20);
} //end draw
